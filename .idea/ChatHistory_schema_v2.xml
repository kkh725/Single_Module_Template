<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChatHistoryState">
    <option name="serializedSessions">
      <map>
        <entry key="86d1c3eb-db9a-46ba-b472-fb9d8757cd4b" value="{&quot;id&quot;:&quot;86d1c3eb-db9a-46ba-b472-fb9d8757cd4b&quot;,&quot;name&quot;:&quot;PendingIntent flag issue in Android 12+ (S+) with com.kkh.single.module.template&quot;,&quot;timestamp&quot;:1753667086724,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```java:C:/AndroidAVD/sources/android-35/android/app/PendingIntent.java, lines\u003dALL(1-1612)\n/*\n * Copyright (C) 2006 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \&quot;License\&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \&quot;AS IS\&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage android.app;\n\nimport static android.app.ActivityManager.INTENT_SENDER_ACTIVITY;\nimport static android.app.ActivityManager.INTENT_SENDER_BROADCAST;\nimport static android.app.ActivityManager.INTENT_SENDER_FOREGROUND_SERVICE;\nimport static android.app.ActivityManager.INTENT_SENDER_SERVICE;\n\nimport android.Manifest.permission;\nimport android.annotation.IntDef;\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.annotation.RequiresPermission;\nimport android.annotation.SystemApi;\nimport android.annotation.SystemApi.Client;\nimport android.annotation.TestApi;\nimport android.app.ActivityManager.PendingIntentInfo;\nimport android.compat.Compatibility;\nimport android.compat.annotation.ChangeId;\nimport android.compat.annotation.EnabledAfter;\nimport android.compat.annotation.EnabledSince;\nimport android.compat.annotation.Overridable;\nimport android.compat.annotation.UnsupportedAppUsage;\nimport android.content.Context;\nimport android.content.IIntentReceiver;\nimport android.content.IIntentSender;\nimport android.content.Intent;\nimport android.content.IntentSender;\nimport android.content.pm.PackageManager.ResolveInfoFlagsBits;\nimport android.content.pm.ParceledListSlice;\nimport android.content.pm.ResolveInfo;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Looper;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.os.RemoteException;\nimport android.os.UserHandle;\nimport android.util.AndroidException;\nimport android.util.ArraySet;\nimport android.util.Log;\nimport android.util.Pair;\nimport android.util.proto.ProtoOutputStream;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.os.IResultReceiver;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.concurrent.Executor;\nimport java.util.function.Consumer;\n\n/**\n * A description of an Intent and target action to perform with it.  Instances\n * of this class are created with {@link #getActivity}, {@link #getActivities},\n * {@link #getBroadcast}, and {@link #getService}; the returned object can be\n * handed to other applications so that they can perform the action you\n * described on your behalf at a later time.\n *\n * \u003cp\u003eBy giving a PendingIntent to another application,\n * you are granting it the right to perform the operation you have specified\n * as if the other application was yourself (with the same permissions and\n * identity).  As such, you should be careful about how you build the PendingIntent:\n * almost always, for example, the base Intent you supply should have the component\n * name explicitly set to one of your own components, to ensure it is ultimately\n * sent there and nowhere else.\n *\n * \u003cp\u003eA PendingIntent itself is simply a reference to a token maintained by\n * the system describing the original data used to retrieve it.  This means\n * that, even if its owning application\u0027s process is killed, the\n * PendingIntent itself will remain usable from other processes that\n * have been given it.  If the creating application later re-retrieves the\n * same kind of PendingIntent (same operation, same Intent action, data,\n * categories, and components, and same flags), it will receive a PendingIntent\n * representing the same token if that is still valid, and can thus call\n * {@link #cancel} to remove it.\n *\n * \u003cp\u003eBecause of this behavior, it is important to know when two Intents\n * are considered to be the same for purposes of retrieving a PendingIntent.\n * A common mistake people make is to create multiple PendingIntent objects\n * with Intents that only vary in their \&quot;extra\&quot; contents, expecting to get\n * a different PendingIntent each time.  This does \u003cem\u003enot\u003c/em\u003e happen.  The\n * parts of the Intent that are used for matching are the same ones defined\n * by {@link Intent#filterEquals(Intent) Intent.filterEquals}.  If you use two\n * Intent objects that are equivalent as per\n * {@link Intent#filterEquals(Intent) Intent.filterEquals}, then you will get\n * the same PendingIntent for both of them.\n *\n * \u003cp\u003eThere are two typical ways to deal with this.\n *\n * \u003cp\u003eIf you truly need multiple distinct PendingIntent objects active at\n * the same time (such as to use as two notifications that are both shown\n * at the same time), then you will need to ensure there is something that\n * is different about them to associate them with different PendingIntents.\n * This may be any of the Intent attributes considered by\n * {@link Intent#filterEquals(Intent) Intent.filterEquals}, or different\n * request code integers supplied to {@link #getActivity}, {@link #getActivities},\n * {@link #getBroadcast}, or {@link #getService}.\n *\n * \u003cp\u003eIf you only need one PendingIntent active at a time for any of the\n * Intents you will use, then you can alternatively use the flags\n * {@link #FLAG_CANCEL_CURRENT} or {@link #FLAG_UPDATE_CURRENT} to either\n * cancel or modify whatever current PendingIntent is associated with the\n * Intent you are supplying.\n *\n * \u003cp\u003eAlso note that flags like {@link #FLAG_ONE_SHOT} or {@link #FLAG_IMMUTABLE} describe the\n * PendingIntent instance and thus, are used to identify it. Any calls to retrieve or modify a\n * PendingIntent created with these flags will also require these flags to be supplied in\n * conjunction with others. E.g. To retrieve an existing PendingIntent created with\n * FLAG_ONE_SHOT, \u003cb\u003eboth\u003c/b\u003e FLAG_ONE_SHOT and FLAG_NO_CREATE need to be supplied.\n */\npublic final class PendingIntent implements Parcelable {\n    private static final String TAG \u003d \&quot;PendingIntent\&quot;;\n    @NonNull\n    private final IIntentSender mTarget;\n    private IBinder mWhitelistToken;\n\n    // cached pending intent information\n    private @Nullable PendingIntentInfo mCachedInfo;\n\n    /**\n     * Structure to store information related to {@link #addCancelListener}, which is rarely used,\n     * so we lazily allocate it to keep the PendingIntent class size small.\n     */\n    private final class CancelListerInfo extends IResultReceiver.Stub {\n        private final ArraySet\u003cPair\u003cExecutor, CancelListener\u003e\u003e mCancelListeners \u003d new ArraySet\u003c\u003e();\n\n        /**\n         * Whether the PI is canceled or not. Note this is essentially a \&quot;cache\&quot; that\u0027s updated\n         * only when the client uses {@link #addCancelListener}. Even if this is false, that\n         * still doesn\u0027t know the PI is *not* canceled, but if it\u0027s true, this PI is definitely\n         * canceled.\n         */\n        private boolean mCanceled;\n\n        @Override\n        public void send(int resultCode, Bundle resultData) throws RemoteException {\n            notifyCancelListeners();\n        }\n    }\n\n    @GuardedBy(\&quot;mTarget\&quot;)\n    private @Nullable CancelListerInfo mCancelListerInfo;\n\n    /**\n     * It is now required to specify either {@link #FLAG_IMMUTABLE}\n     * or {@link #FLAG_MUTABLE} when creating a PendingIntent.\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion \u003d android.os.Build.VERSION_CODES.R)\n    static final long PENDING_INTENT_EXPLICIT_MUTABILITY_REQUIRED \u003d 160794467L;\n\n    /** @hide */\n    @ChangeId\n    @EnabledSince(targetSdkVersion \u003d android.os.Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    @Overridable\n    public static final long BLOCK_MUTABLE_IMPLICIT_PENDING_INTENT \u003d 236704164L;\n\n    /**\n     * Validate options passed in as bundle.\n     * @hide\n     */\n    @ChangeId\n    @EnabledAfter(targetSdkVersion \u003d Build.VERSION_CODES.UPSIDE_DOWN_CAKE)\n    public static final long PENDING_INTENT_OPTIONS_CHECK \u003d 320664730L;\n\n    /** @hide */\n    @IntDef(flag \u003d true,\n            value \u003d {\n                    FLAG_ONE_SHOT,\n                    FLAG_NO_CREATE,\n                    FLAG_CANCEL_CURRENT,\n                    FLAG_UPDATE_CURRENT,\n                    FLAG_IMMUTABLE,\n                    FLAG_MUTABLE,\n                    FLAG_MUTABLE_UNAUDITED,\n                    FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT,\n\n                    Intent.FILL_IN_ACTION,\n                    Intent.FILL_IN_DATA,\n                    Intent.FILL_IN_CATEGORIES,\n                    Intent.FILL_IN_COMPONENT,\n                    Intent.FILL_IN_PACKAGE,\n                    Intent.FILL_IN_SOURCE_BOUNDS,\n                    Intent.FILL_IN_SELECTOR,\n                    Intent.FILL_IN_CLIP_DATA\n            })\n    @Retention(RetentionPolicy.SOURCE)\n    public @interface Flags {}\n\n    /**\n     * Flag indicating that this PendingIntent can be used only once.\n     * For use with {@link #getActivity}, {@link #getBroadcast}, and\n     * {@link #getService}. \u003cp\u003eIf set, after\n     * {@link #send()} is called on it, it will be automatically\n     * canceled for you and any future attempt to send through it will fail.\n     */\n    public static final int FLAG_ONE_SHOT \u003d 1\u003c\u003c30;\n    /**\n     * Flag indicating that if the described PendingIntent does not\n     * already exist, then simply return null instead of creating it.\n     * For use with {@link #getActivity}, {@link #getBroadcast}, and\n     * {@link #getService}.\n     */\n    public static final int FLAG_NO_CREATE \u003d 1\u003c\u003c29;\n    /**\n     * Flag indicating that if the described PendingIntent already exists,\n     * the current one should be canceled before generating a new one.\n     * For use with {@link #getActivity}, {@link #getBroadcast}, and\n     * {@link #getService}. \u003cp\u003eYou can use\n     * this to retrieve a new PendingIntent when you are only changing the\n     * extra data in the Intent; by canceling the previous pending intent,\n     * this ensures that only entities given the new data will be able to\n     * launch it.  If this assurance is not an issue, consider\n     * {@link #FLAG_UPDATE_CURRENT}.\n     */\n    public static final int FLAG_CANCEL_CURRENT \u003d 1\u003c\u003c28;\n    /**\n     * Flag indicating that if the described PendingIntent already exists,\n     * then keep it but replace its extra data with what is in this new\n     * Intent. For use with {@link #getActivity}, {@link #getBroadcast}, and\n     * {@link #getService}. \u003cp\u003eThis can be used if you are creating intents where only the\n     * extras change, and don\u0027t care that any entities that received your\n     * previous PendingIntent will be able to launch it with your new\n     * extras even if they are not explicitly given to it.\n     *\n     * \u003cp\u003e{@link #FLAG_UPDATE_CURRENT} still works even if {@link\n     * #FLAG_IMMUTABLE} is set - the creator of the PendingIntent can always\n     * update the PendingIntent itself. The IMMUTABLE flag only limits the\n     * ability to alter the semantics of the intent that is sent by {@link\n     * #send} by the invoker of {@link #send}.\n     */\n    public static final int FLAG_UPDATE_CURRENT \u003d 1\u003c\u003c27;\n\n    /**\n     * Flag indicating that the created PendingIntent should be immutable.\n     * This means that the additional intent argument passed to the send\n     * methods to fill in unpopulated properties of this intent will be\n     * ignored.\n     *\n     * \u003cp\u003e{@link #FLAG_IMMUTABLE} only limits the ability to alter the\n     * semantics of the intent that is sent by {@link #send} by the invoker of\n     * {@link #send}. The creator of the PendingIntent can always update the\n     * PendingIntent itself via {@link #FLAG_UPDATE_CURRENT}.\n     */\n    public static final int FLAG_IMMUTABLE \u003d 1\u003c\u003c26;\n\n    /**\n     * Flag indicating that the created PendingIntent should be mutable.\n     * This flag cannot be combined with {@link #FLAG_IMMUTABLE}. \u003cp\u003eUp until\n     * {@link android.os.Build.VERSION_CODES#R}, PendingIntents are assumed to\n     * be mutable by default, unless {@link #FLAG_IMMUTABLE} is set. Starting\n     * with {@link android.os.Build.VERSION_CODES#S}, it will be required to\n     * explicitly specify the mutability of PendingIntents on creation with\n     * either {@link #FLAG_IMMUTABLE} or {@link #FLAG_MUTABLE}. It is strongly\n     * recommended to use {@link #FLAG_IMMUTABLE} when creating a\n     * PendingIntent. {@link #FLAG_MUTABLE} should only be used when some\n     * functionality relies on modifying the underlying intent, e.g. any\n     * PendingIntent that needs to be used with inline reply or bubbles.\n     */\n    public static final int FLAG_MUTABLE \u003d 1\u003c\u003c25;\n\n    /**\n     * @deprecated Use {@link #FLAG_IMMUTABLE} or {@link #FLAG_MUTABLE} instead.\n     * @hide\n     */\n    @Deprecated\n    @TestApi\n    public static final int FLAG_MUTABLE_UNAUDITED \u003d FLAG_MUTABLE;\n\n    /**\n     * Flag indicating that the created PendingIntent with {@link #FLAG_MUTABLE}\n     * is allowed to have an unsafe implicit Intent within. \u003cp\u003eStarting with\n     * {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE}, for apps that\n     * target SDK {@link android.os.Build.VERSION_CODES#UPSIDE_DOWN_CAKE} or\n     * higher, creation of a PendingIntent with {@link #FLAG_MUTABLE} and an\n     * implicit Intent within will throw an {@link IllegalArgumentException}\n     * for security reasons. To bypass this check, use\n     * {@link #FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT} when creating a PendingIntent.\n     * However, it is strongly recommended to not to use this flag and make the\n     * Intent explicit or the PendingIntent immutable, thereby making the Intent\n     * safe.\n     */\n    public static final int FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT \u003d 1\u003c\u003c24;\n\n    /**\n     * Exception thrown when trying to send through a PendingIntent that\n     * has been canceled or is otherwise no longer able to execute the request.\n     */\n    public static class CanceledException extends AndroidException {\n        public CanceledException() {\n        }\n\n        public CanceledException(String name) {\n            super(name);\n        }\n\n        public CanceledException(Exception cause) {\n            super(cause);\n        }\n    }\n\n    /**\n     * Callback interface for discovering when a send operation has\n     * completed.  Primarily for use with a PendingIntent that is\n     * performing a broadcast, this provides the same information as\n     * calling {@link Context#sendOrderedBroadcast(Intent, String,\n     * android.content.BroadcastReceiver, Handler, int, String, Bundle)\n     * Context.sendBroadcast()} with a final BroadcastReceiver.\n     */\n    public interface OnFinished {\n        /**\n         * Called when a send operation as completed.\n         *\n         * @param pendingIntent The PendingIntent this operation was sent through.\n         * @param intent The original Intent that was sent.\n         * @param resultCode The final result code determined by the send.\n         * @param resultData The final data collected by a broadcast.\n         * @param resultExtras The final extras collected by a broadcast.\n         */\n        void onSendFinished(PendingIntent pendingIntent, Intent intent,\n                int resultCode, String resultData, Bundle resultExtras);\n    }\n\n    private static class FinishedDispatcher extends IIntentReceiver.Stub\n            implements Runnable {\n        private final PendingIntent mPendingIntent;\n        private final OnFinished mWho;\n        private final Handler mHandler;\n        private Intent mIntent;\n        private int mResultCode;\n        private String mResultData;\n        private Bundle mResultExtras;\n        private static Handler sDefaultSystemHandler;\n        FinishedDispatcher(PendingIntent pi, OnFinished who, Handler handler) {\n            mPendingIntent \u003d pi;\n            mWho \u003d who;\n            if (handler \u003d\u003d null \u0026\u0026 ActivityThread.isSystem()) {\n                // We assign a default handler for the system process to avoid deadlocks when\n                // processing receivers in various components that hold global service locks.\n                if (sDefaultSystemHandler \u003d\u003d null) {\n                    sDefaultSystemHandler \u003d new Handler(Looper.getMainLooper());\n                }\n                mHandler \u003d sDefaultSystemHandler;\n            } else {\n                mHandler \u003d handler;\n            }\n        }\n        public void performReceive(Intent intent, int resultCode, String data,\n                Bundle extras, boolean serialized, boolean sticky, int sendingUser) {\n            mIntent \u003d intent;\n            mResultCode \u003d resultCode;\n            mResultData \u003d data;\n            mResultExtras \u003d extras;\n            if (mHandler \u003d\u003d null) {\n                run();\n            } else {\n                mHandler.post(this);\n            }\n        }\n        public void run() {\n            mWho.onSendFinished(mPendingIntent, mIntent, mResultCode,\n                    mResultData, mResultExtras);\n        }\n    }\n\n    /**\n     * Listener for observing when pending intents are written to a parcel.\n     *\n     * @hide\n     */\n    public interface OnMarshaledListener {\n        /**\n         * Called when a pending intent is written to a parcel.\n         *\n         * @param intent The pending intent.\n         * @param parcel The parcel to which it was written.\n         * @param flags The parcel flags when it was written.\n         */\n        void onMarshaled(PendingIntent intent, Parcel parcel, int flags);\n    }\n\n    private static final ThreadLocal\u003cList\u003cOnMarshaledListener\u003e\u003e sOnMarshaledListener \u003d\n            ThreadLocal.withInitial(ArrayList::new);\n\n    /**\n     * Registers an listener for pending intents being written to a parcel. This replaces any\n     * listeners previously added.\n     *\n     * @param listener The listener, null to clear.\n     *\n     * @hide\n     */\n    @UnsupportedAppUsage(maxTargetSdk \u003d Build.VERSION_CODES.R, trackingBug \u003d 170729553)\n    public static void setOnMarshaledListener(OnMarshaledListener listener) {\n        final List\u003cOnMarshaledListener\u003e listeners \u003d sOnMarshaledListener.get();\n        listeners.clear();\n        if (listener !\u003d null) {\n            listeners.add(listener);\n        }\n    }\n\n    /**\n     * Adds a listener for pending intents being written to a parcel.\n     * @hide\n     */\n    static void addOnMarshaledListener(OnMarshaledListener listener) {\n        sOnMarshaledListener.get().add(listener);\n    }\n\n    /**\n     * Removes a listener for pending intents being written to a parcel.\n     * @hide\n     */\n    static void removeOnMarshaledListener(OnMarshaledListener listener) {\n        sOnMarshaledListener.get().remove(listener);\n    }\n\n    private static void checkPendingIntent(int flags, @NonNull Intent intent,\n            @NonNull Context context, boolean isActivityResultType) {\n        final boolean isFlagImmutableSet \u003d (flags \u0026 PendingIntent.FLAG_IMMUTABLE) !\u003d 0;\n        final boolean isFlagMutableSet \u003d (flags \u0026 PendingIntent.FLAG_MUTABLE) !\u003d 0;\n        final String packageName \u003d context.getPackageName();\n\n        if (isFlagImmutableSet \u0026\u0026 isFlagMutableSet) {\n            throw new IllegalArgumentException(\n                \&quot;Cannot set both FLAG_IMMUTABLE and FLAG_MUTABLE for PendingIntent\&quot;);\n        }\n\n        if (Compatibility.isChangeEnabled(PENDING_INTENT_EXPLICIT_MUTABILITY_REQUIRED)\n                \u0026\u0026 !isFlagImmutableSet \u0026\u0026 !isFlagMutableSet) {\n            String msg \u003d packageName + \&quot;: Targeting S+ (version \&quot; + Build.VERSION_CODES.S\n                    + \&quot; and above) requires that one of FLAG_IMMUTABLE or FLAG_MUTABLE\&quot;\n                    + \&quot; be specified when creating a PendingIntent.\\nStrongly consider\&quot;\n                    + \&quot; using FLAG_IMMUTABLE, only use FLAG_MUTABLE if some functionality\&quot;\n                    + \&quot; depends on the PendingIntent being mutable, e.g. if it needs to\&quot;\n                    + \&quot; be used with inline replies or bubbles.\&quot;;\n                throw new IllegalArgumentException(msg);\n        }\n\n        // For apps with target SDK \u003c U, warn that creation or retrieval of a mutable implicit\n        // PendingIntent that is not of type {@link ActivityManager#INTENT_SENDER_ACTIVITY_RESULT}\n        // will be blocked from target SDK U onwards for security reasons. The block itself\n        // happens on the server side, but this warning has to stay here to preserve the client\n        // side stack trace for app developers.\n        if (isNewMutableDisallowedImplicitPendingIntent(flags, intent, isActivityResultType)\n                \u0026\u0026 !Compatibility.isChangeEnabled(BLOCK_MUTABLE_IMPLICIT_PENDING_INTENT)) {\n            String msg \u003d \&quot;New mutable implicit PendingIntent: pkg\u003d\&quot; + packageName\n                    + \&quot;, action\u003d\&quot; + intent.getAction()\n                    + \&quot;, featureId\u003d\&quot; + context.getAttributionTag()\n                    + \&quot;. This will be blocked once the app targets U+\&quot;\n                    + \&quot; for security reasons.\&quot;;\n            Log.w(TAG, new StackTrace(msg));\n        }\n    }\n\n    /** @hide */\n    public static boolean isNewMutableDisallowedImplicitPendingIntent(int flags,\n            @NonNull Intent intent, boolean isActivityResultType) {\n        if (isActivityResultType) {\n            // Pending intents of type {@link ActivityManager#INTENT_SENDER_ACTIVITY_RESULT}\n            // should be ignored as they are intrinsically tied to a target which means they\n            // are already explicit.\n            return false;\n        }\n        boolean isFlagNoCreateSet \u003d (flags \u0026 PendingIntent.FLAG_NO_CREATE) !\u003d 0;\n        boolean isFlagMutableSet \u003d (flags \u0026 PendingIntent.FLAG_MUTABLE) !\u003d 0;\n        boolean isImplicit \u003d (intent.getComponent() \u003d\u003d null) \u0026\u0026 (intent.getPackage() \u003d\u003d null);\n        boolean isFlagAllowUnsafeImplicitIntentSet \u003d\n                (flags \u0026 PendingIntent.FLAG_ALLOW_UNSAFE_IMPLICIT_INTENT) !\u003d 0;\n        return !isFlagNoCreateSet \u0026\u0026 isFlagMutableSet \u0026\u0026 isImplicit\n                \u0026\u0026 !isFlagAllowUnsafeImplicitIntentSet;\n    }\n\n    /**\n     * Retrieve a PendingIntent that will start a new activity, like calling\n     * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.\n     * Note that the activity will be started outside of the context of an\n     * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK\n     * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an \u003cem\u003eexplicit intent\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the activity.\n     * @param requestCode Private request code for the sender\n     * @param intent Intent of the activity to be launched.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    @SuppressWarnings(\&quot;AndroidFrameworkPendingIntentMutability\&quot;)\n    public static PendingIntent getActivity(Context context, int requestCode,\n            Intent intent, @Flags int flags) {\n        return getActivity(context, requestCode, intent, flags, null);\n    }\n\n    /**\n     * Retrieve a PendingIntent that will start a new activity, like calling\n     * {@link Context#startActivity(Intent) Context.startActivity(Intent)}.\n     * Note that the activity will be started outside of the context of an\n     * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK\n     * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an \u003cem\u003eexplicit intent\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the activity.\n     * @param requestCode Private request code for the sender\n     * @param intent Intent of the activity to be launched.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     * @param options Additional options for how the Activity should be started.\n     * May be null if there are no options.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    @SuppressWarnings(\&quot;AndroidFrameworkPendingIntentMutability\&quot;)\n    public static PendingIntent getActivity(Context context, int requestCode,\n            @NonNull Intent intent, @Flags int flags, @Nullable Bundle options) {\n        // Some tests only mock Context.getUserId(), so fallback to the id Context.getUser() is null\n        final UserHandle user \u003d context.getUser();\n        return getActivityAsUser(context, requestCode, intent, flags, options,\n                user !\u003d null ? user : UserHandle.of(context.getUserId()));\n    }\n\n    /**\n     * @hide\n     * Note that UserHandle.CURRENT will be interpreted at the time the\n     * activity is started, not when the pending intent is created.\n     */\n    @UnsupportedAppUsage\n    public static PendingIntent getActivityAsUser(Context context, int requestCode,\n            @NonNull Intent intent, int flags, Bundle options, UserHandle user) {\n        String packageName \u003d context.getPackageName();\n        String resolvedType \u003d intent.resolveTypeIfNeeded(context.getContentResolver());\n        checkPendingIntent(flags, intent, context, /* isActivityResultType */ false);\n        try {\n            intent.migrateExtraStreamToClipData(context);\n            intent.prepareToLeaveProcess(context);\n            IIntentSender target \u003d\n                ActivityManager.getService().getIntentSenderWithFeature(\n                    INTENT_SENDER_ACTIVITY, packageName,\n                    context.getAttributionTag(), null, null, requestCode, new Intent[] { intent },\n                    resolvedType !\u003d null ? new String[] { resolvedType } : null,\n                    flags, options, user.getIdentifier());\n            return target !\u003d null ? new PendingIntent(target) : null;\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Like {@link #getActivity(Context, int, Intent, int)}, but allows an\n     * array of Intents to be supplied.  The last Intent in the array is\n     * taken as the primary key for the PendingIntent, like the single Intent\n     * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending\n     * the resulting PendingIntent, all of the Intents are started in the same\n     * way as they would be by passing them to {@link Context#startActivities(Intent[])}.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003e\n     * The \u003cem\u003efirst\u003c/em\u003e intent in the array will be started outside of the context of an\n     * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK\n     * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after\n     * the first in the array are started in the context of the previous activity\n     * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)\n     * \u003c/p\u003e\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003e\n     * The \u003cem\u003elast\u003c/em\u003e intent in the array represents the key for the\n     * PendingIntent.  In other words, it is the significant element for matching\n     * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},\n     * its content will be the subject of replacement by\n     * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.\n     * This is because it is the most specific of the supplied intents, and the\n     * UI the user actually sees when the intents are started.\n     * \u003c/p\u003e\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent} objects\n     * you supply here should almost always be \u003cem\u003eexplicit intents\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the activity.\n     * @param requestCode Private request code for the sender\n     * @param intents Array of Intents of the activities to be launched.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    @SuppressWarnings(\&quot;AndroidFrameworkPendingIntentMutability\&quot;)\n    public static PendingIntent getActivities(Context context, int requestCode,\n            @NonNull Intent[] intents, @Flags int flags) {\n        return getActivities(context, requestCode, intents, flags, null);\n    }\n\n    /**\n     * Like {@link #getActivity(Context, int, Intent, int)}, but allows an\n     * array of Intents to be supplied.  The last Intent in the array is\n     * taken as the primary key for the PendingIntent, like the single Intent\n     * given to {@link #getActivity(Context, int, Intent, int)}.  Upon sending\n     * the resulting PendingIntent, all of the Intents are started in the same\n     * way as they would be by passing them to {@link Context#startActivities(Intent[])}.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003e\n     * The \u003cem\u003efirst\u003c/em\u003e intent in the array will be started outside of the context of an\n     * existing activity, so you must use the {@link Intent#FLAG_ACTIVITY_NEW_TASK\n     * Intent.FLAG_ACTIVITY_NEW_TASK} launch flag in the Intent.  (Activities after\n     * the first in the array are started in the context of the previous activity\n     * in the array, so FLAG_ACTIVITY_NEW_TASK is not needed nor desired for them.)\n     * \u003c/p\u003e\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003e\n     * The \u003cem\u003elast\u003c/em\u003e intent in the array represents the key for the\n     * PendingIntent.  In other words, it is the significant element for matching\n     * (as done with the single intent given to {@link #getActivity(Context, int, Intent, int)},\n     * its content will be the subject of replacement by\n     * {@link #send(Context, int, Intent)} and {@link #FLAG_UPDATE_CURRENT}, etc.\n     * This is because it is the most specific of the supplied intents, and the\n     * UI the user actually sees when the intents are started.\n     * \u003c/p\u003e\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent} objects\n     * you supply here should almost always be \u003cem\u003eexplicit intents\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the activity.\n     * @param requestCode Private request code for the sender\n     * @param intents Array of Intents of the activities to be launched.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * {@link #FLAG_IMMUTABLE} or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    @SuppressWarnings(\&quot;AndroidFrameworkPendingIntentMutability\&quot;)\n    public static PendingIntent getActivities(Context context, int requestCode,\n            @NonNull Intent[] intents, @Flags int flags, @Nullable Bundle options) {\n        // Some tests only mock Context.getUserId(), so fallback to the id Context.getUser() is null\n        final UserHandle user \u003d context.getUser();\n        return getActivitiesAsUser(context, requestCode, intents, flags, options,\n                user !\u003d null ? user : UserHandle.of(context.getUserId()));\n    }\n\n    /**\n     * @hide\n     * Note that UserHandle.CURRENT will be interpreted at the time the\n     * activity is started, not when the pending intent is created.\n     */\n    public static PendingIntent getActivitiesAsUser(Context context, int requestCode,\n            @NonNull Intent[] intents, int flags, Bundle options, UserHandle user) {\n        String packageName \u003d context.getPackageName();\n        String[] resolvedTypes \u003d new String[intents.length];\n        for (int i\u003d0; i\u003cintents.length; i++) {\n            intents[i].migrateExtraStreamToClipData(context);\n            intents[i].prepareToLeaveProcess(context);\n            resolvedTypes[i] \u003d intents[i].resolveTypeIfNeeded(context.getContentResolver());\n            checkPendingIntent(flags, intents[i], context, /* isActivityResultType */ false);\n        }\n        try {\n            IIntentSender target \u003d\n                ActivityManager.getService().getIntentSenderWithFeature(\n                    INTENT_SENDER_ACTIVITY, packageName,\n                    context.getAttributionTag(), null, null, requestCode, intents, resolvedTypes,\n                    flags, options, user.getIdentifier());\n            return target !\u003d null ? new PendingIntent(target) : null;\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Retrieve a PendingIntent that will perform a broadcast, like calling\n     * {@link Context#sendBroadcast(Intent) Context.sendBroadcast()}.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an \u003cem\u003eexplicit intent\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should perform\n     * the broadcast.\n     * @param requestCode Private request code for the sender\n     * @param intent The Intent to be broadcast.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * {@link #FLAG_IMMUTABLE} or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    @SuppressWarnings(\&quot;AndroidFrameworkPendingIntentMutability\&quot;)\n    public static PendingIntent getBroadcast(Context context, int requestCode,\n            @NonNull Intent intent, @Flags int flags) {\n        return getBroadcastAsUser(context, requestCode, intent, flags, context.getUser());\n    }\n\n    /**\n     * @hide\n     * Note that UserHandle.CURRENT will be interpreted at the time the\n     * broadcast is sent, not when the pending intent is created.\n     */\n    @UnsupportedAppUsage\n    public static PendingIntent getBroadcastAsUser(Context context, int requestCode,\n            Intent intent, int flags, UserHandle userHandle) {\n        String packageName \u003d context.getPackageName();\n        String resolvedType \u003d intent.resolveTypeIfNeeded(context.getContentResolver());\n        checkPendingIntent(flags, intent, context, /* isActivityResultType */ false);\n        try {\n            intent.prepareToLeaveProcess(context);\n            IIntentSender target \u003d\n                ActivityManager.getService().getIntentSenderWithFeature(\n                    INTENT_SENDER_BROADCAST, packageName,\n                    context.getAttributionTag(), null, null, requestCode, new Intent[] { intent },\n                    resolvedType !\u003d null ? new String[] { resolvedType } : null,\n                    flags, null, userHandle.getIdentifier());\n            return target !\u003d null ? new PendingIntent(target) : null;\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Retrieve a PendingIntent that will start a service, like calling\n     * {@link Context#startService Context.startService()}.  The start\n     * arguments given to the service will come from the extras of the Intent.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an \u003cem\u003eexplicit intent\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the service.\n     * @param requestCode Private request code for the sender\n     * @param intent An Intent describing the service to be started.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * {@link #FLAG_IMMUTABLE} or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    public static PendingIntent getService(Context context, int requestCode,\n            @NonNull Intent intent, @Flags int flags) {\n        return buildServicePendingIntent(context, requestCode, intent, flags,\n                INTENT_SENDER_SERVICE);\n    }\n\n    /**\n     * Retrieve a PendingIntent that will start a foreground service, like calling\n     * {@link Context#startForegroundService Context.startForegroundService()}.  The start\n     * arguments given to the service will come from the extras of the Intent.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eFor security reasons, the {@link android.content.Intent}\n     * you supply here should almost always be an \u003cem\u003eexplicit intent\u003c/em\u003e,\n     * that is specify an explicit component to be delivered to through\n     * {@link Intent#setClass(android.content.Context, Class) Intent.setClass}\u003c/p\u003e\n     *\n     * @param context The Context in which this PendingIntent should start\n     * the service.\n     * @param requestCode Private request code for the sender\n     * @param intent An Intent describing the service to be started.\n     * @param flags May be {@link #FLAG_ONE_SHOT}, {@link #FLAG_NO_CREATE},\n     * {@link #FLAG_CANCEL_CURRENT}, {@link #FLAG_UPDATE_CURRENT},\n     * {@link #FLAG_IMMUTABLE} or any of the flags as supported by\n     * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts\n     * of the intent that can be supplied when the actual send happens.\n     *\n     * @return Returns an existing or new PendingIntent matching the given\n     * parameters.  May return null only if {@link #FLAG_NO_CREATE} has been\n     * supplied.\n     */\n    public static PendingIntent getForegroundService(Context context, int requestCode,\n            @NonNull Intent intent, @Flags int flags) {\n        return buildServicePendingIntent(context, requestCode, intent, flags,\n                INTENT_SENDER_FOREGROUND_SERVICE);\n    }\n\n    private static PendingIntent buildServicePendingIntent(Context context, int requestCode,\n            Intent intent, int flags, int serviceKind) {\n        String packageName \u003d context.getPackageName();\n        String resolvedType \u003d intent.resolveTypeIfNeeded(context.getContentResolver());\n        checkPendingIntent(flags, intent, context, /* isActivityResultType */ false);\n        try {\n            intent.prepareToLeaveProcess(context);\n            IIntentSender target \u003d\n                ActivityManager.getService().getIntentSenderWithFeature(\n                    serviceKind, packageName, context.getAttributionTag(),\n                    null, null, requestCode, new Intent[] { intent },\n                    resolvedType !\u003d null ? new String[] { resolvedType } : null,\n                    flags, null, context.getUserId());\n            return target !\u003d null ? new PendingIntent(target) : null;\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Retrieve a IntentSender object that wraps the existing sender of the PendingIntent\n     *\n     * @return Returns a IntentSender object that wraps the sender of PendingIntent\n     *\n     */\n    @NonNull\n    public IntentSender getIntentSender() {\n        return new IntentSender(mTarget, mWhitelistToken);\n    }\n\n    /**\n     * Cancel a currently active PendingIntent.  Only the original application\n     * owning a PendingIntent can cancel it.\n     */\n    public void cancel() {\n        try {\n            ActivityManager.getService().cancelIntentSender(mTarget);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send() throws CanceledException {\n        send(null, 0, null, null, null, null, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent.\n     *\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(int code) throws CanceledException {\n        send(null, code, null, null, null, null, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to specify information about the Intent to use.\n     *\n     * @param context The Context of the caller.\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     * @param intent Additional Intent data.  See {@link Intent#fillIn\n     * Intent.fillIn()} for information on how this is applied to the\n     * original Intent. If flag {@link #FLAG_IMMUTABLE} was set when this\n     * pending intent was created, this argument will be ignored.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(Context context, int code, @Nullable Intent intent)\n            throws CanceledException {\n        send(context, code, intent, null, null, null, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, supplying additional\n     * options for the operation.\n     *\n     * @param options Additional options the caller would like to provide to modify the\n     * sending behavior.  May be built from an {@link ActivityOptions} to apply to an\n     * activity start.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(@Nullable Bundle options) throws CanceledException {\n        send(null, 0, null, null, null, null, options);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to be notified when the send has completed.\n     *\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     * @param onFinished The object to call back on when the send has\n     * completed, or null for no callback.\n     * @param handler Handler identifying the thread on which the callback\n     * should happen.  If null, the callback will happen from the thread\n     * pool of the process.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(int code, @Nullable OnFinished onFinished, @Nullable Handler handler)\n            throws CanceledException {\n        send(null, code, null, onFinished, handler, null, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to specify information about the Intent to use and be notified\n     * when the send has completed.\n     *\n     * \u003cp\u003eFor the intent parameter, a PendingIntent\n     * often has restrictions on which fields can be supplied here, based on\n     * how the PendingIntent was retrieved in {@link #getActivity},\n     * {@link #getBroadcast}, or {@link #getService}.\n     *\n     * @param context The Context of the caller.  This may be null if\n     * \u003cvar\u003eintent\u003c/var\u003e is also null.\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     * @param intent Additional Intent data.  See {@link Intent#fillIn\n     * Intent.fillIn()} for information on how this is applied to the\n     * original Intent.  Use null to not modify the original Intent.\n     * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was\n     * created, this argument will be ignored.\n     * @param onFinished The object to call back on when the send has\n     * completed, or null for no callback.\n     * @param handler Handler identifying the thread on which the callback\n     * should happen.  If null, the callback will happen from the thread\n     * pool of the process.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(Context context, int code, @Nullable Intent intent,\n            @Nullable OnFinished onFinished, @Nullable Handler handler) throws CanceledException {\n        send(context, code, intent, onFinished, handler, null, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to specify information about the Intent to use and be notified\n     * when the send has completed.\n     *\n     * \u003cp\u003eFor the intent parameter, a PendingIntent\n     * often has restrictions on which fields can be supplied here, based on\n     * how the PendingIntent was retrieved in {@link #getActivity},\n     * {@link #getBroadcast}, or {@link #getService}.\n     *\n     * @param context The Context of the caller.  This may be null if\n     * \u003cvar\u003eintent\u003c/var\u003e is also null.\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     * @param intent Additional Intent data.  See {@link Intent#fillIn\n     * Intent.fillIn()} for information on how this is applied to the\n     * original Intent.  Use null to not modify the original Intent.\n     * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was\n     * created, this argument will be ignored.\n     * @param onFinished The object to call back on when the send has\n     * completed, or null for no callback.\n     * @param handler Handler identifying the thread on which the callback\n     * should happen.  If null, the callback will happen from the thread\n     * pool of the process.\n     * @param requiredPermission Name of permission that a recipient of the PendingIntent\n     * is required to hold.  This is only valid for broadcast intents, and\n     * corresponds to the permission argument in\n     * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.\n     * If null, no permission is required.\n     *\n     * @see #send(Context, int, Intent, android.app.PendingIntent.OnFinished, Handler, String,\n     *          Bundle)\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(Context context, int code, @Nullable Intent intent,\n            @Nullable OnFinished onFinished, @Nullable Handler handler,\n            @Nullable String requiredPermission)\n            throws CanceledException {\n        send(context, code, intent, onFinished, handler, requiredPermission, null);\n    }\n\n    /**\n     * Perform the operation associated with this PendingIntent, allowing the\n     * caller to specify information about the Intent to use and be notified\n     * when the send has completed.\n     *\n     * \u003cp\u003eFor the intent parameter, a PendingIntent\n     * often has restrictions on which fields can be supplied here, based on\n     * how the PendingIntent was retrieved in {@link #getActivity},\n     * {@link #getBroadcast}, or {@link #getService}.\n     *\n     * @param context The Context of the caller.  This may be null if\n     * \u003cvar\u003eintent\u003c/var\u003e is also null.\n     * @param code Result code to supply back to the PendingIntent\u0027s target.\n     * @param intent Additional Intent data.  See {@link Intent#fillIn\n     * Intent.fillIn()} for information on how this is applied to the\n     * original Intent.  Use null to not modify the original Intent.\n     * If flag {@link #FLAG_IMMUTABLE} was set when this pending intent was\n     * created, this argument will be ignored.\n     * @param onFinished The object to call back on when the send has\n     * completed, or null for no callback.\n     * @param handler Handler identifying the thread on which the callback\n     * should happen.  If null, the callback will happen from the thread\n     * pool of the process.\n     * @param requiredPermission Name of permission that a recipient of the PendingIntent\n     * is required to hold.  This is only valid for broadcast intents, and\n     * corresponds to the permission argument in\n     * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.\n     * If null, no permission is required.\n     * @param options Additional options the caller would like to provide to modify the sending\n     * behavior.  May be built from an {@link ActivityOptions} to apply to an activity start.\n     *\n     * @throws CanceledException Throws CanceledException if the PendingIntent\n     * is no longer allowing more intents to be sent through it.\n     */\n    public void send(Context context, int code, @Nullable Intent intent,\n            @Nullable OnFinished onFinished, @Nullable Handler handler,\n            @Nullable String requiredPermission, @Nullable Bundle options)\n            throws CanceledException {\n        if (sendAndReturnResult(context, code, intent, onFinished, handler, requiredPermission,\n                options) \u003c 0) {\n            throw new CanceledException();\n        }\n    }\n\n    /**\n     * Like {@link #send}, but returns the result\n     * @hide\n     */\n    public int sendAndReturnResult(Context context, int code, @Nullable Intent intent,\n            @Nullable OnFinished onFinished, @Nullable Handler handler,\n            @Nullable String requiredPermission, @Nullable Bundle options)\n            throws CanceledException {\n        try {\n            String resolvedType \u003d intent !\u003d null ?\n                    intent.resolveTypeIfNeeded(context.getContentResolver())\n                    : null;\n\n            if (context !\u003d null \u0026\u0026 isActivity()) {\n                // Set the context display id as preferred for this activity launches, so that it\n                // can land on caller\u0027s display. Or just brought the task to front at the display\n                // where it was on since it has higher preference.\n                ActivityOptions activityOptions \u003d options !\u003d null ? new ActivityOptions(options)\n                        : ActivityOptions.makeBasic();\n                activityOptions.setCallerDisplayId(context.getDisplayId());\n                options \u003d activityOptions.toBundle();\n            }\n\n            final IApplicationThread app \u003d ActivityThread.currentActivityThread()\n                    .getApplicationThread();\n            return ActivityManager.getService().sendIntentSender(app,\n                    mTarget, mWhitelistToken, code, intent, resolvedType,\n                    onFinished !\u003d null\n                            ? new FinishedDispatcher(this, onFinished, handler)\n                            : null,\n                    requiredPermission, options);\n        } catch (RemoteException e) {\n            throw new CanceledException(e);\n        }\n    }\n\n    /**\n     * @deprecated Renamed to {@link #getCreatorPackage()}.\n     */\n    @Deprecated\n    @Nullable\n    public String getTargetPackage() {\n        return getCreatorPackage();\n    }\n\n    /**\n     * Return the package name of the application that created this\n     * PendingIntent, that is the identity under which you will actually be\n     * sending the Intent.  The returned string is supplied by the system, so\n     * that an application can not spoof its package.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eBe careful about how you use this.  All this tells you is\n     * who created the PendingIntent.  It does \u003cstrong\u003enot\u003c/strong\u003e tell you who\n     * handed the PendingIntent to you: that is, PendingIntent objects are intended to be\n     * passed between applications, so the PendingIntent you receive from an application\n     * could actually be one it received from another application, meaning the result\n     * you get here will identify the original application.  Because of this, you should\n     * only use this information to identify who you expect to be interacting with\n     * through a {@link #send} call, not who gave you the PendingIntent.\u003c/p\u003e\n     *\n     * @return The package name of the PendingIntent.\n     */\n    @Nullable\n    public String getCreatorPackage() {\n        return getCachedInfo().getCreatorPackage();\n    }\n\n    /**\n     * Return the uid of the application that created this\n     * PendingIntent, that is the identity under which you will actually be\n     * sending the Intent.  The returned integer is supplied by the system, so\n     * that an application can not spoof its uid.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eBe careful about how you use this.  All this tells you is\n     * who created the PendingIntent.  It does \u003cstrong\u003enot\u003c/strong\u003e tell you who\n     * handed the PendingIntent to you: that is, PendingIntent objects are intended to be\n     * passed between applications, so the PendingIntent you receive from an application\n     * could actually be one it received from another application, meaning the result\n     * you get here will identify the original application.  Because of this, you should\n     * only use this information to identify who you expect to be interacting with\n     * through a {@link #send} call, not who gave you the PendingIntent.\u003c/p\u003e\n     *\n     * @return The uid of the PendingIntent, or -1 if there is\n     * none associated with it.\n     */\n    public int getCreatorUid() {\n        return getCachedInfo().getCreatorUid();\n    }\n\n    /**\n     * @hide\n     * @deprecated use {@link #addCancelListener(Executor, CancelListener)} instead.\n     */\n    @Deprecated\n    public void registerCancelListener(@NonNull CancelListener cancelListener) {\n        if (!addCancelListener(Runnable::run, cancelListener)) {\n            // Call the callback right away synchronously, if the PI has been canceled already.\n            cancelListener.onCanceled(this);\n        }\n    }\n\n    /**\n     * Register a listener to when this pendingIntent is canceled.\n     *\n     * @return true if the listener has been set successfully. false if the {@link PendingIntent}\n     * has already been canceled.\n     *\n     * @hide\n     */\n    @SystemApi(client \u003d SystemApi.Client.MODULE_LIBRARIES)\n    @TestApi\n    public boolean addCancelListener(@NonNull Executor executor,\n            @NonNull CancelListener cancelListener) {\n        synchronized (mTarget) {\n            if (mCancelListerInfo !\u003d null \u0026\u0026 mCancelListerInfo.mCanceled) {\n                return false;\n            }\n            if (mCancelListerInfo \u003d\u003d null) {\n                mCancelListerInfo \u003d new CancelListerInfo();\n            }\n            final CancelListerInfo cli \u003d mCancelListerInfo;\n\n            boolean wasEmpty \u003d cli.mCancelListeners.isEmpty();\n            cli.mCancelListeners.add(Pair.create(executor, cancelListener));\n            if (wasEmpty) {\n                boolean success;\n                try {\n                    success \u003d ActivityManager.getService().registerIntentSenderCancelListenerEx(\n                            mTarget, cli);\n                } catch (RemoteException e) {\n                    throw e.rethrowFromSystemServer();\n                }\n                if (!success) {\n                    cli.mCanceled \u003d true;\n                }\n                return success;\n            } else {\n                return !cli.mCanceled;\n            }\n        }\n    }\n\n    private void notifyCancelListeners() {\n        ArraySet\u003cPair\u003cExecutor, CancelListener\u003e\u003e cancelListeners;\n        synchronized (mTarget) {\n            // When notifyCancelListeners() is called, mCancelListerInfo must always be non-null.\n            final CancelListerInfo cli \u003d mCancelListerInfo;\n            cli.mCanceled \u003d true;\n            cancelListeners \u003d new ArraySet\u003c\u003e(cli.mCancelListeners);\n            cli.mCancelListeners.clear();\n        }\n        int size \u003d cancelListeners.size();\n        for (int i \u003d 0; i \u003c size; i++) {\n            final Pair\u003cExecutor, CancelListener\u003e pair \u003d cancelListeners.valueAt(i);\n            pair.first.execute(() -\u003e pair.second.onCanceled(this));\n        }\n    }\n\n    /**\n     * @hide\n     * @deprecated use {@link #removeCancelListener(CancelListener)} instead.\n     */\n    @Deprecated\n    public void unregisterCancelListener(CancelListener cancelListener) {\n        removeCancelListener(cancelListener);\n    }\n\n    /**\n     * Un-register a listener to when this pendingIntent is canceled.\n     *\n     * @hide\n     */\n    @SystemApi(client \u003d SystemApi.Client.MODULE_LIBRARIES)\n    @TestApi\n    public void removeCancelListener(@NonNull CancelListener cancelListener) {\n        synchronized (mTarget) {\n            final CancelListerInfo cli \u003d mCancelListerInfo;\n            if (cli \u003d\u003d null || cli.mCancelListeners.size() \u003d\u003d 0) {\n                return;\n            }\n            for (int i \u003d cli.mCancelListeners.size() - 1; i \u003e\u003d 0; i--) {\n                if (cli.mCancelListeners.valueAt(i).second \u003d\u003d cancelListener) {\n                    cli.mCancelListeners.removeAt(i);\n                }\n            }\n            if (cli.mCancelListeners.isEmpty()) {\n                try {\n                    ActivityManager.getService().unregisterIntentSenderCancelListener(mTarget,\n                            cli);\n                } catch (RemoteException e) {\n                    throw e.rethrowFromSystemServer();\n                }\n            }\n        }\n    }\n\n    /**\n     * Return the user handle of the application that created this\n     * PendingIntent, that is the user under which you will actually be\n     * sending the Intent.  The returned UserHandle is supplied by the system, so\n     * that an application can not spoof its user.  See\n     * {@link android.os.Process#myUserHandle() Process.myUserHandle()} for\n     * more explanation of user handles.\n     *\n     * \u003cp class\u003d\&quot;note\&quot;\u003eBe careful about how you use this.  All this tells you is\n     * who created the PendingIntent.  It does \u003cstrong\u003enot\u003c/strong\u003e tell you who\n     * handed the PendingIntent to you: that is, PendingIntent objects are intended to be\n     * passed between applications, so the PendingIntent you receive from an application\n     * could actually be one it received from another application, meaning the result\n     * you get here will identify the original application.  Because of this, you should\n     * only use this information to identify who you expect to be interacting with\n     * through a {@link #send} call, not who gave you the PendingIntent.\u003c/p\u003e\n     *\n     * @return The user handle of the PendingIntent\n     */\n    @NonNull\n    public UserHandle getCreatorUserHandle() {\n        int uid \u003d getCachedInfo().getCreatorUid();\n        return UserHandle.getUserHandleForUid(uid);\n    }\n\n    /**\n     * @hide\n     * Check to verify that this PendingIntent targets a specific package.\n     */\n    public boolean isTargetedToPackage() {\n        try {\n            return ActivityManager.getService()\n                .isIntentSenderTargetedToPackage(mTarget);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Check if this PendingIntent is marked with {@link #FLAG_IMMUTABLE}.\n     */\n    public boolean isImmutable() {\n        return getCachedInfo().isImmutable();\n    }\n\n    /**\n     * @return TRUE if this {@link PendingIntent} was created with\n     * {@link #getActivity} or {@link #getActivities}.\n     */\n    public boolean isActivity() {\n        return getCachedInfo().getIntentSenderType() \u003d\u003d INTENT_SENDER_ACTIVITY;\n    }\n\n    /**\n     * @return TRUE if this {@link PendingIntent} was created with {@link #getForegroundService}.\n     */\n    public boolean isForegroundService() {\n        return getCachedInfo().getIntentSenderType() \u003d\u003d INTENT_SENDER_FOREGROUND_SERVICE;\n    }\n\n    /**\n     * @return TRUE if this {@link PendingIntent} was created with {@link #getService}.\n     */\n    public boolean isService() {\n        return getCachedInfo().getIntentSenderType() \u003d\u003d INTENT_SENDER_SERVICE;\n    }\n\n    /**\n     * @return TRUE if this {@link PendingIntent} was created with {@link #getBroadcast}.\n     */\n    public boolean isBroadcast() {\n        return getCachedInfo().getIntentSenderType() \u003d\u003d INTENT_SENDER_BROADCAST;\n    }\n\n    /**\n     * @hide\n     * Return the Intent of this PendingIntent.\n     */\n    @UnsupportedAppUsage\n    public Intent getIntent() {\n        try {\n            return ActivityManager.getService()\n                .getIntentForIntentSender(mTarget);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * @hide\n     * Return descriptive tag for this PendingIntent.\n     */\n    @UnsupportedAppUsage\n    public String getTag(String prefix) {\n        try {\n            return ActivityManager.getService()\n                .getTagForIntentSender(mTarget, prefix);\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Resolve the intent set in this {@link PendingIntent}. Note if the pending intent is\n     * generated for another user, the resulting component may not exist on the calling user.\n     * Use {@link android.content.pm.ApplicationInfo#uid} of the resulting\n     * {@link android.content.pm.ComponentInfo} with\n     * {@link android.os.UserHandle#getUserHandleForUid(int)} to see which user will receive\n     * the intent.\n     *\n     * @param flags MATCH_* flags from {@link android.content.pm.PackageManager}.\n     * @hide\n     */\n    @RequiresPermission(permission.GET_INTENT_SENDER_INTENT)\n    @SystemApi(client \u003d Client.MODULE_LIBRARIES)\n    @TestApi\n    public @NonNull List\u003cResolveInfo\u003e queryIntentComponents(@ResolveInfoFlagsBits int flags) {\n        try {\n            ParceledListSlice\u003cResolveInfo\u003e parceledList \u003d ActivityManager.getService()\n                    .queryIntentComponentsForIntentSender(mTarget, flags);\n            if (parceledList \u003d\u003d null) {\n                return Collections.emptyList();\n            }\n            return parceledList.getList();\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Comparison operator on two PendingIntent objects, such that true is returned when they\n     * represent {@link Intent}s that are equal as per {@link Intent#filterEquals}.\n     *\n     * @param other The other PendingIntent to compare against.\n     * @return True if action, data, type, class, and categories on two intents are the same.\n     *\n     * @hide\n     */\n    @SystemApi(client \u003d SystemApi.Client.MODULE_LIBRARIES)\n    @TestApi\n    @RequiresPermission(android.Manifest.permission.GET_INTENT_SENDER_INTENT)\n    public boolean intentFilterEquals(@Nullable PendingIntent other) {\n        if (other \u003d\u003d null) {\n            return false;\n        }\n        try {\n            return ActivityManager.getService().getIntentForIntentSender(other.mTarget)\n                    .filterEquals(getIntent());\n        } catch (RemoteException e) {\n            throw e.rethrowFromSystemServer();\n        }\n    }\n\n    /**\n     * Comparison operator on two PendingIntent objects, such that true\n     * is returned then they both represent the same operation from the\n     * same package.  This allows you to use {@link #getActivity},\n     * {@link #getBroadcast}, or {@link #getService} multiple times (even\n     * across a process being killed), resulting in different PendingIntent\n     * objects but whose equals() method identifies them as being the same\n     * operation.\n     */\n    @Override\n    public boolean equals(@Nullable Object otherObj) {\n        if (otherObj instanceof PendingIntent) {\n            return mTarget.asBinder().equals(((PendingIntent)otherObj)\n                    .mTarget.asBinder());\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return mTarget.asBinder().hashCode();\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb \u003d new StringBuilder(128);\n        sb.append(\&quot;PendingIntent{\&quot;);\n        sb.append(Integer.toHexString(System.identityHashCode(this)));\n        sb.append(\&quot;: \&quot;);\n        sb.append(mTarget.asBinder());\n        sb.append(\u0027}\u0027);\n        return sb.toString();\n    }\n\n    /**\n     * See {@link Intent#visitUris(Consumer)}.\n     *\n     * @hide\n     */\n    public void visitUris(@NonNull Consumer\u003cUri\u003e visitor) {\n        if (android.app.Flags.visitRiskyUris()) {\n            Intent intent \u003d Binder.withCleanCallingIdentity(this::getIntent);\n\n            if (intent !\u003d null) {\n                intent.visitUris(visitor);\n            }\n        }\n    }\n\n    /** @hide */\n    public void dumpDebug(ProtoOutputStream proto, long fieldId) {\n        final long token \u003d proto.start(fieldId);\n        proto.write(PendingIntentProto.TARGET, mTarget.asBinder().toString());\n        proto.end(token);\n    }\n\n    public int describeContents() {\n        return 0;\n    }\n\n    public void writeToParcel(Parcel out, int flags) {\n        out.writeStrongBinder(mTarget.asBinder());\n        final List\u003cOnMarshaledListener\u003e listeners \u003d sOnMarshaledListener.get();\n        final int numListeners \u003d listeners.size();\n        for (int i \u003d 0; i \u003c numListeners; i++) {\n            listeners.get(i).onMarshaled(this, out, flags);\n        }\n    }\n\n    public static final @NonNull Creator\u003cPendingIntent\u003e CREATOR \u003d new Creator\u003cPendingIntent\u003e() {\n        public PendingIntent createFromParcel(Parcel in) {\n            IBinder target \u003d in.readStrongBinder();\n            return target !\u003d null\n                    ? new PendingIntent(target, in.getClassCookie(PendingIntent.class))\n                    : null;\n        }\n\n        public PendingIntent[] newArray(int size) {\n            return new PendingIntent[size];\n        }\n    };\n\n    /**\n     * Convenience function for writing either a PendingIntent or null pointer to\n     * a Parcel.  You must use this with {@link #readPendingIntentOrNullFromParcel}\n     * for later reading it.\n     *\n     * @param sender The PendingIntent to write, or null.\n     * @param out Where to write the PendingIntent.\n     */\n    public static void writePendingIntentOrNullToParcel(@Nullable PendingIntent sender,\n            @NonNull Parcel out) {\n        out.writeStrongBinder(sender !\u003d null ? sender.mTarget.asBinder() : null);\n        if (sender !\u003d null) {\n            final List\u003cOnMarshaledListener\u003e listeners \u003d sOnMarshaledListener.get();\n            final int numListeners \u003d listeners.size();\n            for (int i \u003d 0; i \u003c numListeners; i++) {\n                listeners.get(i).onMarshaled(sender, out, 0 /* flags */);\n            }\n        }\n    }\n\n    /**\n     * Convenience function for reading either a PendingIntent or null pointer from\n     * a Parcel.  You must have previously written the PendingIntent with\n     * {@link #writePendingIntentOrNullToParcel}.\n     *\n     * @param in The Parcel containing the written PendingIntent.\n     *\n     * @return Returns the PendingIntent read from the Parcel, or null if null had\n     * been written.\n     */\n    @Nullable\n    public static PendingIntent readPendingIntentOrNullFromParcel(@NonNull Parcel in) {\n        IBinder b \u003d in.readStrongBinder();\n        return b !\u003d null ? new PendingIntent(b, in.getClassCookie(PendingIntent.class)) : null;\n    }\n\n    /**\n     * Creates a PendingIntent with the given target.\n     * @param target the backing IIntentSender\n     * @hide\n     */\n    public PendingIntent(IIntentSender target) {\n        mTarget \u003d Objects.requireNonNull(target);\n    }\n\n    /*package*/ PendingIntent(IBinder target, Object cookie) {\n        mTarget \u003d Objects.requireNonNull(IIntentSender.Stub.asInterface(target));\n        if (cookie !\u003d null) {\n            mWhitelistToken \u003d (IBinder)cookie;\n        }\n    }\n\n    /** @hide */\n    public IIntentSender getTarget() {\n        return mTarget;\n    }\n\n    /** @hide */\n    public IBinder getWhitelistToken() {\n        return mWhitelistToken;\n    }\n\n    /**\n     * A listener to when a pending intent is canceled\n     *\n     * @hide\n     */\n    @SystemApi(client \u003d SystemApi.Client.MODULE_LIBRARIES)\n    @TestApi\n    public interface CancelListener {\n        /**\n         * Called when a Pending Intent is canceled.\n         *\n         * @param intent The intent that was canceled.\n         */\n        void onCanceled(@NonNull PendingIntent intent);\n    }\n\n    private PendingIntentInfo getCachedInfo() {\n        if (mCachedInfo \u003d\u003d null) {\n            try {\n                mCachedInfo \u003d ActivityManager.getService().getInfoForIntentSender(mTarget);\n            } catch (RemoteException e) {\n                throw e.rethrowFromSystemServer();\n            }\n        }\n\n        return mCachedInfo;\n    }\n}\n\n```\n\u003c/current_file\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\njava.lang.IllegalArgumentException: com.kkh.single.module.template: Targeting S+ (version 31 and above) requires that one of FLAG_IMMUTABLE or FLAG_MUTABLE be specified when creating a PendingIntent.\n                                                                                                     Strongly consider using FLAG_IMMUTABLE, only use FLAG_MUTABLE if some functionality depends on the PendingIntent being mutable, e.g. if it needs to be used with inline replies or bubbles.        ?\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;   PendingIntent   \u003cbr\u003e**FLAG_IMMUTABLE**  **FLAG_MUTABLE**     .\u003cbr\u003e\nAndroid 12 (API 31, S)      .\n\n** **\n- `PendingIntent.getActivity()`, `getService()`, `getBroadcast()`   , flags \u003cbr\u003e `PendingIntent.FLAG_IMMUTABLE`  `PendingIntent.FLAG_MUTABLE`     .\n-   ,  API  mutability    .\n\n---\n\n###    , PendingIntent   \n\n**:**\n- PendingIntent   , flags     .\n\n:\n```java\n// ( )\nPendingIntent pendingIntent \u003d PendingIntent.getActivity(context, 0, intent, 0);\n\n// ( )\nPendingIntent pendingIntent \u003d PendingIntent.getActivity(\n    context, 0, intent, PendingIntent.FLAG_IMMUTABLE\n);\n//   \nPendingIntent pendingIntent \u003d PendingIntent.getActivity(\n    context, 0, intent, PendingIntent.FLAG_MUTABLE\n);\n```\n\n** ** `FLAG_IMMUTABLE`   .  \n**inline reply, bubbles       FLAG_IMMUTABLE ** .\n\n---\n\n###    \n\n1.  `PendingIntent`   ( Notification, Alarm, Service, Broadcast )  .\n2. flag  0    `FLAG_IMMUTABLE`  ( ) `FLAG_MUTABLE` .\n3.      PendingIntent    .  \n     (hint: `PendingIntent.get`) ?\n\n---\n\n#### \n-    .\n- PendingIntent      .\n-   PendingIntent       .\n\n PendingIntent        .  \n?&quot;}]},{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\n\u003cadditional_data\u003e\nBelow are some potentially helpful/relevant pieces of information for figuring out to respond\n\u003ccurrent_file\u003e\n```java:C:/AndroidAVD/sources/android-35/android/app/PendingIntent.java, lines\u003dALL(1-1612)\n(file is identical to original version)\n```\n\u003c/current_file\u003e\n\u003c/additional_data\u003e\n\u003cuser_query\u003e\npendingintent     \n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;,     `PendingIntent`     ,  \n      :\n\n---\n\n### 1.   /\n-  (: , , Notification   )  `PendingIntent` ,  \n  flag    .\n- ,   , ** **   .  \n-  Firebase,   /   .\n\n---\n\n### 2.  (, React Native    )\n-   ,  ,  SDK(,  )   .\n\n---\n\n### 3. /  \n-       PendingIntent   .\n\n---\n\n##    ?\n\n1. **  PendingIntent  **  \n   -    PendingIntent   `\&quot;PendingIntent.\&quot;` .\n   -  Kotlin  ?  `\&quot;PendingIntent\&quot;`    .\n2. **Notification, AlarmManager, WorkManager, JobIntentService  **  \n   -      PendingIntent  .\n3. **Gradle   **  \n   -  (Firebase, , , ,   )         .\n\n---\n\n##    (/ )\n\n- **Java/Kotlin **  \n  - `PendingIntent`\n  - `getActivity(`\n  - `getBroadcast(`\n  - `getService(`\n  - `.flag`  `FLAG_`\n- ** (`build.gradle`)**\n  - Firebase,  (OneSignal, Airbridge ), /,     \n\n---\n\n##   \n\n-    PendingIntent         .\n-      ()         .\n\n     (   ,  )  ?  \n,           ?  \n       !&quot;}]}]}" />
      </map>
    </option>
  </component>
</project>